############################

############################
# JAVA MAVEN
############################

############################

# Maven

# super pom

her pom.xml bir super pom'dan türer. süper pom'da default değerler yer alır. bu değerler, runtime sırasında pom.xml'i okuyan ve işleyecek olan program (eclipse maven eklentisi gibi) süper pom'u oluşturur. bu değerleri saklamakta yarar vardır. zira sonraki maven sürümlerinde değişen değerler olabilir. super pom'da bulanabilecek örnek değerler: test classes directory, source classes directory, plugins...

# effective pom.xml

projemizdeki pom.xml + super pom'un birleşimidir. pom.xml'imizdeki her değer super.pom'dakileri override eder.

"effective pom.xml" 'imizi görmek istediğimizde bir tool (örnek IDE) bize pom.xml'imizden "effective pom.xml" otomatik generade eder.

örnek source code dizini nerde olduğu pom.xml'de yazmaz. fakat effective pom.xml'da yazar. effective pom.xml tüm detayları içerir. bu dosyayı backup alıp, soruce code içine koymakta yarar olabilir.

effective pom.xml'i pom.xml'e komple yapıştırırsak hiçbir şey değişmez. yine projemiz çalışmaya devam eder.

effective pom'u komut satırından bu şekilde görebiliriz:

> mvn help:effective-pom

# maven tanımları

büyükten küçüğe:

__lifecycle --> build phase --> goal__

__execution__ tanımı goal ile aynı seviyede. execution aşağda anlatılmaktadır.

# lifecycles

- clean
- default
- site

her lifecycles içinde birçok phase vardır. liste şu şekilde: (kaynak: (source-id: 419))

clean lifecycle phases:

| Phase      | Description                                                   |
|------------|---------------------------------------------------------------|
| pre-clean  | execute processes needed prior to the actual project cleaning |
| clean      | remove all files generated by the previous build              |
| post-clean | execute processes needed to finalize the project cleaning     |

default lifecycle phases:

| Phase                   | Description                                                                                                                                                                   |
|-------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| validate                | validate the project is correct and all necessary information is available.                                                                                                   |
| initialize              | initialize build state, e.g. set properties or create directories.                                                                                                            |
| generate-sources        | generate any source code for inclusion in compilation.                                                                                                                        |
| process-sources         | process the source code, for example to filter any values.                                                                                                                    |
| generate-resources      | generate resources for inclusion in the package.                                                                                                                              |
| process-resources       | copy and process the resources into the destination directory, ready for packaging.                                                                                           |
| compile                 | compile the source code of the project.                                                                                                                                       |
| process-classes         | post-process the generated files from compilation, for example to do bytecode enhancement on Java classes.                                                                    |
| generate-test-sources   | generate any test source code for inclusion in compilation.                                                                                                                   |
| process-test-sources    | process the test source code, for example to filter any values.                                                                                                               |
| generate-test-resources | create resources for testing.                                                                                                                                                 |
| process-test-resources  | copy and process the resources into the test destination directory.                                                                                                           |
| test-compile            | compile the test source code into the test destination directory                                                                                                              |
| process-test-classes    | post-process the generated files from test compilation, for example to do bytecode enhancement on Java classes. For Maven 2.0.5 and above.                                    |
| test                    | run tests using a suitable unit testing framework. These tests should not require the code be packaged or deployed.                                                           |
| prepare-package         | perform any operations necessary to prepare a package before the actual packaging. This often results in an unpacked, processed version of the package. (Maven 2.1 and above) |
| package                 | take the compiled code and package it in its distributable format, such as a JAR.                                                                                             |
| pre-integration-test    | perform actions required before integration tests are executed. This may involve things such as setting up the required environment.                                          |
| integration-test        | process and deploy the package if necessary into an environment where integration tests can be run.                                                                           |
| post-integration-test   | perform actions required after integration tests have been executed. This may including cleaning up the environment.                                                          |
| verify                  | run any checks to verify the package is valid and meets quality criteria.                                                                                                     |
| install                 | install the package into the local repository, for use as a dependency in other projects locally.                                                                             |
| deploy                  | done in an integration or release environment, copies the final package to the remote repository for sharing with other developers and projects.                              |

Site Lifecycle phases:

| Phase       | Description                                                                                  |
|-------------|----------------------------------------------------------------------------------------------|
| pre-site    | execute processes needed prior to the actual project site generation                         |
| site        | generate the project's site documentation                                                    |
| post-site   | execute processes needed to finalize the site generation, and to prepare for site deployment |
| site-deploy | deploy the generated site documentation to the specified web server                          |

# örnek komutlar:

- mvn clean deploy

  clean lifecycle'ı ve ardından deploy fazı çağrılır. deploy fazına gelene kadarki tüm fazları çağırır.

- mvn maven-compiler-plugin:2.5.1:compile

  maven-compiler-plugin plugin'inin 'compile' goal'unu çağırır. diğer lifecycle içerisindeki fazları çağırmaz. 

  Burada 'compile' plugin'in bir goal'üdür. herhangi bir isim alabilir. 1 plugin goal'ü istenirse, maven'ın default fazlarından herhangi birine bound edilebilir. böylece maven'ın o fazı çağrıldığında otomatik olarak maven bound edilen goal'i de çağırır.
  
  Hatta istenirse bir goal birden fazla maven fazına da bound edilebilir.

- mvn clean maven-compiler-plugin:2.5.1:compile deploy

  önce clean lifecyle'si, sonra plugin'in sadece ilgili goal'ü, ve sonra deploy fazı'na gelene kadarki tüm fazlar çağrılır.

Default olarak her faz'a bağlı(bounded) bazı plugin'ler var. Fakat bu ilişkiler(bound'lar), pom.xml'deki packaging(jar, war...) değerine göre değişiklik göstermektedir. kaynak: (source-id: 1)

# örnek goal tanımlama
1 goal birden fazla faz tarafından çağrılabilir.

goal tanımlamak için plugin şart. her plugin'in goal'leri var. aşağıdaki xml config'inde görüldüğü gibi bir pluginin hangi fazlarda çalışacağı ve hangi goal'lerin o fazlarda olduğu belirtilmektedir.

Eğer bir goal hiçbir faza dahil edilmezse, o zaman sadece(ancak) o goal'i tek başına komut satırından tetikleyerek run edebiliriz.

```xml
<build>
  <plugins>
          <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-antrun-plugin</artifactId>
            <version>1.1</version>
            <executions>
                  <execution>
                          <id>id.validate</id>
                          <phase>validate</phase>
                          <goals>
                              <goal>run</goal>
                          </goals>
                          <configuration>
                              <tasks>
                                  <echo>in validate phase (the first phase of build lifecycle)</echo>
                              </tasks>
                          </configuration>
                  </execution>
```

# execution
execution bir goal'in farklı konfigürasyonlarda çalışmasını sağlamak için yaratılmıştır. her execution'ın bir id'si var. her execution'ın bir configi var. her execution farklı goal'lere yada fazlara atayabiliriz.

# sık karşılaşılan maven komut satırı hataları

- ## mvn build
"mvn build" komutu hata verir. çünkü böyle bir faz yada goal yoktur.

eclipse'in M2Eclipse plugini maven entegrasyonu sağlamaktadır. bu plugin yüklü iken, bir maven projesine sağ tıklandığında "maven build" seçeneği görülecektir. bu seçenek, daha önce çalıştırılmış olan bir maven build configürasyonunu run edecektir. eğer birden fazla config var ise, hangisini çalıştırmak istediğimizi soracaktır. yeni config yaratmak veya eskilerini düzenlemek için "maven build ..." seçeneğine tıklanmalıdır.

- ## "mvn clean install" vs "mvn install"
"mvn install" komutu, "clean" ayrı bir lifecycle olduğundan, clean fazını çalıştırmaz ve bu sebeple target dizinini silmez. clean olmadığı için ve install çalıştırdığımız için şu hatayı alabiliriz: eğer bir plugin build sırasında source code generate ediyor ise, target'ta zaten o source'lar varolduğundan dublicate tarzı bir hata alabiliriz.

yani; sırası ile:

> mvn clean install

> mvn install

çalıştırırsak, pluginlerlere bağlı olarak hata alma durumumuz olabilir.

aynı sebepten:

> mvn clean install

> mvn deploy

komutu da hata verebilir.

# target vs source jdk version

target sürümü uygulamanın minimum hangi versiyon jdk üzerinde çalıştırılacağı anlamına geliyor. target jar/war dosyası o jdk sürümününe uyumlu class'ları üretiyor.

source ise; uygulamanın kodlarının hangi versiyon ile derleneceğini belirtiyor. uygulama yeni teknolojide çalışabilir fakat kodların eski sürümler ile kontrol edilmesi istenebilir. bunun birkaç sebebi olabilir;

1- ilerdeki zamanlarda projenin eski sürüm java'larda çalışması istenebilir. o zaman sadece target'ı düşürmek yeterli olacaktır.

2- kontrol amaçlı.

3- proje'nin target ve source versiyonu aynı olduğunu varsayalım. fakat spesifik olarak sadece benim sistemin için derleme yapmak istiyorum. benim sistemim çok güncel. güncel bir java'ya göre derlenen daha hızlı çalışacağından, sadece target versiyonunu yükseltip derleme yapabiliriz.

# transitive dependency
Transitive kelime anlamı: geçişli

maven dependency'leri 2 çeşittir:

- Direct: kendi projemizde pom.xml'imizde olan dependency'dir.

- Transitive: bizim pom.xml'imide bulunan dependency'lerin dependency'leridir.

Transitive dependency'leri de sayarsak bir projede, aynı dependency'nin farklı sürümleri denk gelecektir. Dependency tree komutu ile bu listeyi görebiliriz. Fakat target'a atılacak olan jar direct dependency'ye en yakın olan olacaktır (tabi "optional" gibi paraetresi olan dependency'ler ignore edilecektir...). kaynak: (source-id: 2) title: "transitive dependencies", sub-title: "Dependency mediation".

# dependency

her dependency'de ayrı ayrı scope değeri belirtilirtilebilir. scope asagidaki degerler olabilir:

- test: bu kütüphanenin sadece test pakwetlerini derlerken ve test execution'larında (test runtime'ında) kullanılacağı anlamına gelir.

- provided: kütüphanen sadece derleme aşamasına olacağı ve output (target) klasöründeki jar/war dosyasına konmayacağı anlamına gelir. örnek weblogic içerisinde olan bir libary'yi scope=provided yapmak gereklidir.

  provided lib'ler compile sırasında kullanılır. bu sebeple lombok'ta provided'tır. 

- runtime: sadece runtime sırasında bu jar targetta bulunur. compile time'da bu jar kullanılmaz.

- compile: default scope'tur. hem compile hemde targetta jar'ın içinde bulunurlar.

- system: bu kütüphanenin path'inin maven repolarında olmayacağı ve local dizinde olacağı anlamına gelir. bu sebeple jar'ın local'deki path'ini ek olarak yazmak gereklidir. örneğin "C:\Libs\abc.jar" gibi. canlı ve IDE-developer ortamında aynı dizin kullanılmaktadır. compile sırasında bu jar kullanılır, aynı zamanda bu dizin manifest'te class-path'e de eklenir. yani jar'ın içine atılmaz. çünkü zaten her ortamda aynı dizinde olması beklenir. bu durumda; scope'u provided'a benzemiş olur. (system scope'u güncel maven sürümlerinde deprecated oldu).

  system scopu'u test yada compile time gibi bölünemez. sistemin tüm akışında bu jar olacaktır.

- import: sadece dependencyManagement içerisinde kullanılabilir. eğer dependencyManagement ve dependency'mizin tipi pom ise, o zaman bunu koymak zorundayız. scope'u import yaptığımız şeyler BOM oluyor. BOM'un pom'unun içindeki tüm dependency'ler, bizim dependency management'te ayrı ayrı tanımlanmış gibi varsayılıyor. örnek:

```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>X</groupId>
            <artifactId>Y</artifactId>
            <version>Z</version>
            <scope>import</scope>
            <type>pom</type>
        </dependency>

        <!-- Y içerisinde olan tüm dependency'ler bu satırda yazılmış gibi varsayılıyor. -->
    </dependencies>
</dependencyManagement>
```

# transitive dependency scopes
transitive dependency'nin scope'u eğer compile veya runtime ise, aynı şekilde bizim jar'ımıza da aynı scope ile yansır. eğer transitive dependency test veya provided ise o jar tamamen ihmal edilir. kaynak: (source-id: 3) "Dependency Scope" başlığındaki tablo.

# scope=import vs parent
scope=import sadece dependency sürümlerini tanımlamak için kullanılabilir. oysa parent pom'daki tüm pom, alt-projelere aynen inherit edilir. 

# dependency type
bazı durumlarda dependency'nin dosya uzantısı (.jar, .war ...) bilinsede, aynı uzantılı dosyalarda farklı amaçlar söz konusu olabilir.

Bu listede tüm type'lar listelenmiştir: (source-id: 4)

Linkteki listeye bakıldığında .jar uzantılı olsada, type=java-source olarak set ettiğimizde, o jar classpath'e eklenmiyor. Oysa type=jar deseydik, o jar classpath'e eklenecekti.

# classifier
her maven projesinin birden fazla classifier tanımı olabilir. örneğin; abc projemiz de 1 classifier'siz bir de source classifier'li jar'ı olabilir. hangi classifier'lerin olacağı abc projesinin pom.xml'inde tanımlanmalıdır. Bu durumda şu jar'lar target'ta oluşur:

- abc-$version.jar
- abc-$version-$classifier.jar --> örnek: abc-2-source.jar

abc-2-source.jar'ımız source sınıfılarını da barındırır. böylece abc'yi kullanan projeler debug sırasında, kodumuzu kolay debug edebilir. Buna benzer birçok farklı amaç için classifier oluşturabiliriz. En sık kullanılan başka bir örnej ise "javadoc" classifier'ıdır. doc'ları da attach edip jar içine koyabiliriz. Böylece abc'yi dependency olarak kullanan projelerde, IDE metod isimlerinin açıklamalarını, developer'a otomatik gösterir.

Classifier string'i tamamen custom'dır. istediğimiz herhangi bir string değerini verebiliriz.

Custom bir örnek üzerinden gidelim: Sunucumuz olsun. Bu sunucumuzun mpodel, client ve sunucu parçaları var. Hepsi için ayrı repo veya modül açmak yerine, hepsini ayrı classifier'lerle dağıtabiliriz. Bunun için sunucu'nun pom'unda aşağıdakiler olmalıdır:

"server" projesinin pom.xml'i

```xml
<build>
  <plugins>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-jar-plugin</artifactId>
      <version>3.1.0</version>
      <executions>
        <execution>
          <id>package-client</id>
          <phase>package</phase>
          <goals>
            <goal>jar</goal>
          </goals>
          <configuration>
            <classifier>client</classifier>
            <includes>
             <include>**/com/app1/client/**</include>
            </includes>
          </configuration>
        </execution>
        <execution>
          <id>package-model</id>
          <phase>package</phase>
          <goals>
            <goal>jar</goal>
          </goals>
          <configuration>
            <classifier>model</classifier>
            <includes>
              <include>**/com/app1/model/**</include>
            </includes>
          </configuration>
        </execution>
      </executions>
    </plugin>
  </plugins>
</build>
```

Artık bizim projeyi client ile çağıracak olan developer kendi projesinde bunları dependency'ye eklemelidir:

```xml
<dependencies>
  <dependency>
    <groupId>com.app1</groupId>
    <artifactId>server</artifactId>
    <version>1.0-SNAPSHOT</version>
    <classifier>model</classifier>
  </dependency>
  <dependency>
    <groupId>com.app1</groupId>
    <artifactId>server</artifactId>
    <version>1.0-SNAPSHOT</version>
    <classifier>client</classifier>
  </dependency>
</dependencies>
```

İstersen model ve client'ı birleştirebiliriz, çünkü ayrı ayrı yazılmasına gerek olmamalı.

# profiles

profiller ile; derleme sırasında, belirtilen dinamik dizin (aşağıdaki örnekte directory), javadaki "resource" klasörünün root'una kopyalanır.

```xml
<profiles>
  <profile>
   <id>test</id>
   <activation>
        <activeByDefault>true</activeByDefault>
   </activation>
   <build>
   <resources>
        <resource>
            <directory>src/main/resources/profiles/test</directory>
        </resource>
   </resources>
   </build>
  </profile>
```

profiller ile aynı zamanda her profilin farklı reposu, eklentisi, dependency gibi seçenekleri olması da ayarlanabilmektedir.

# plugin-management vs plugin

plugin management içerisinde plugin'ler, projenin alt modülündeki yada ilgili proje için sadece bir tanımdır. bunların kullanıp kullanılmayacağına her projenin pom'u kendi karar verir. kullanılmak istenen eklenti build-plugins içerisinde belirtilmesi yeterlidir. eğer override eidlmesi gereken parametreler var ise onlar mutlaka geçilmelidir.

parent projede:

```xml
 <build>
   ...
   <pluginManagement>
     <plugins>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
         <version>2.6</version>
         <executions>
             <execution>
```

alt projede:

```xml
 <build>
   ...
   <pluginManagement>
     <plugins>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
         <!-- versiyon dahi belirtmeye gerek yok. isteğe bağlı burada config'ler override edilebilir. -->
        </plugin>
```

# dependency-management

plugin-management'e benzer yapıda dependency'leri yönetebilmek içinde bir kullanım mevcuttur. örneğin spring frameworkü her sürümü için ayrı ayrı dependency-management içerisinde tüm spring kütüphanelerini içeren pom'lar yaratmıştır. istediğimiz bir versiyon'u dependency-management 'a ekleyerek sadece kullanacağımız kütüphaneleri dependency kısmına eklememiz yeterlidir. hiçbir dependency için sürüm belirtmek zournda kalmayız.

# maven wrapper

pom.xml IDE tarafından okunur ve ilgili işlemlerin koşması sağlanır. fakat maven IDE'siz de çalıştırılabilir. maven default command-line uygulaması mevcut. BU IDE 'lerin içine de gömülebilir, işletim sistemine de kurulabilir. maven wrapper basit bir script'tir. bu script projenin root'unda pom.xml in yanında bulunur. bu script işletim sisteminin komut satırında çalıştırıldığında maven'ı işletim sistemi path'inde arar, yoksa download eder ve maven komutlarını çalıştırmamızı sağlar. portabilite kazandırır. IDE den bağısmzlığı getirir. pom.xml'e uygun maven sürümünü bulmaya çalışır. her işletim sistemi için farklı script dosyası olmalıdır, çünkü her OS'un kendi sciprt dili vardır.

piyasada bir çok maven-wrapper dosyası oluşturan yazılımlar vardır.

maven-wrapper'ların maven eklnetileri de olabiliyor. bu maven eklentileri ile lifecycle içeirisinde maven-wrapper script dosyalarını oluşturulması sağlanıyor.

maven-wrapper maven standartlarında belirtilmiş bir şey değildir.

# Archetype

türkçe kelime anlamı: prototip

mvn komutu ile yeni proje oluşturduğumuzda, oluşan dosyaların/dizinlerin ve pom.xml'lerde neler yazacağı gibi bilgilerin olduğu template'e verilen isimdir. kullanılan Archetype'ın tanımına göre, generate ettiğimiz projede alt-modüller de olabilir.

piyasada birçok Archetype mevcuttur. kendi Archetype'ımızı da yapabilir. sadece basit java projesi için bile birçok farklı kaynaktan Archetype bulabiliriz.

Archetype bilgisi (hangi Archetype'ı seçtiğimiz) effective pom.xml'da dahi yazmaz. çünkü Archetype sadece pom.xml'i ve dizinleri (/src, /test...) oluşturur. super pom'u değiştiremez. eğer super pom'dan değiştirmesi şart olan bir değer var ise, zaten generate ettiği pom'da istediği değerleri override edebilir.

# SNAPSHOT
SNAPSHOT is a special keyword known by repository servers (like Nexus) and maven command.

SNAPSHOT keyword should always set as suffix only.

SNAPSHOT basically means that this version is still under development. So it can be updated anytme. so as a best-practice:
- you can update a snapshot version by pushing jar file to remote repository (like Nexus).
- you can not update a non-SNAPSHOT version by pushing jar (repository should not allow you). 

But both above behaviors can be changed by remote repository configurations. maven command has built-in push plugin but it does not cares about this behavior (the above rules).

Now let's take a look how maven command manages local maven repository ("$HOME/.m2" directory). Maven as default does not re-check the local jar files (decendencies) on every "install" command if they are updated on remote repository. The only way to enable re-check jar from remote are:

- pass "-U (update snapshots)" parameter to "mvn install" command. It will check the hash of remote jar and local (.m2) jar file. If it is different, then it downloads the jar from remote to local. "Update snapshot" only works for the SNAPSHOT suffixed jars. kaynak: (source-id: 5) 

- setup the configs on pom.xml as example:

```xml
  <repositories>
    <repository>
      <releases>
        <enabled>false</enabled>
        <updatePolicy>always</updatePolicy>
        <checksumPolicy>warn</checksumPolicy>
      </releases>
      <snapshots>
        <enabled>true</enabled>
        <updatePolicy>never</updatePolicy>
        <checksumPolicy>fail</checksumPolicy>
      </snapshots>
      <name>Nexus Snapshots</name>
      <id>snapshots-repo</id>
      <url>https://oss.sonatype.org/content/repositories/snapshots</url>
      <layout>default</layout>
    </repository>

    ...

  </repositories>

  <pluginRepositories>
    ...
  </pluginRepositories>
  ...
</project>
```

some options for above example (on pom.xml):

- checksumPolicy: ignore or fail or warn
- layout: default or legacy(for maven 1.x support)
- enabled: enables or disables this repository/config
- updatePolicy: always or daily (default) or interval:X (where X is an integer in minutes) or never - This only works on "mvn install" command and only checks time-stamp of jar files on m2 directory. kaynak: (source-id: 6) title: "User Centre" subtitle: "POM Reference" subtitle: "Repositories".
- checksumPolicy: ignore or fail or warn. - checks whatever hash of jar file is same or not.

# revision
Bu konunun kaynağı: (source-id: 7)

```xml
<project>
   <groupId>group1</groupId>
   <artifactId>artifact1</artifactId>
   <version>${revision}</version>
</project>
```

revision özel bir keyword. Artık bu şekilde sürüm derlemesi yapabiliriz:

```sh
mvn -Drevision=1.0.0-SNAPSHOT clean package
```

Eğer ilgili pom.xml'imize bunu eklersek:

```xml
<properties>
   <revision>1.0.0-SNAPSHOT</revision>
</properties>
```

default değer gibi varsayılır. -Drevision yollamazsak properties'de yazan değer kullanılır.

# maven plugins

A Maven plugin is a group of goals.

bazı plugin'ler "build", bazıları ise "reporting" xml tag'i içine alınıyor (neden bu şekilde bir mimari uygulanmış bulanamadım). Bu durum ile ilgili kurallar burada belirtilmiştir: (source-id: 435)

Özetle:

- clean ve default hayat döngüsünde olan plugin'ler mutlaka "build" xml tag'i içine alınmalıdır. site hayat döngüsündeki plugin'ler ise "reporting" ve "build" içerisine alınabilir.
- build içerisine alınan site plugin'lerinin configürasyonları ignore edilir.
- eğer elle "P" plugin'in "G" goal'ini çağrırsak; önce reporting tag'indeki configürasyonları okur. eğer yok ise build içerisine alınan "P" plugin'in configürasyonlarını okur.

Aşağıda maven projesi tarafından desteklenen resmi plugin'lerin listesi verilmiştir.

kaynak: (source-id: 436)

| Plugin                      | Description                                                                                                            |
|-----------------------------|------------------------------------------------------------------------------------------------------------------------|
| ** Core plugins **          | ** Plugins corresponding to default core phases (ie. clean, compile). They may have multiple goals as well.**          |
| clean                       | Clean up after the build.                                                                                              |
| compiler                    | Compiles Java sources.                                                                                                 |
| deploy                      | Deploy the built artifact to the remote repository.                                                                    |
| failsafe                    | Run the JUnit integration tests in an isolated classloader.                                                            |
| install                     | Install the built artifact into the local repository.                                                                  |
| resources                   | Copy the resources to the output directory for including in the JAR.                                                   |
| site                        | Generate a site for the current project.                                                                               |
| surefire                    | Run the JUnit unit tests in an isolated classloader.                                                                   |
| verifier                    | Useful for integration tests - verifies the existence of certain conditions.                                           |
| ** Packaging types/tools ** | ** These plugins relate to packaging respective artifact types. **                                                     |
| ear                         | Generate an EAR from the current project.                                                                              |
| ejb                         | Build an EJB (and optional client) from the current project.                                                           |
| jar                         | Build a JAR from the current project.                                                                                  |
| rar                         | Build a RAR from the current project.                                                                                  |
| war                         | Build a WAR from the current project.                                                                                  |
| app-client/acr              | Build a JavaEE application client from the current project.                                                            |
| shade                       | Build an Uber-JAR from the current project, including dependencies.                                                    |
| source                      | Build a source-JAR from the current project.                                                                           |
| jlink                       | Build Java Run Time Image.                                                                                             |
| jmod                        | Build Java JMod files.                                                                                                 |
| ** Reporting plugins**      | ** Plugins which generate reports, are configured as reports in the POM and run under the site generation lifecycle.** |
| changelog                   | Generate a list of recent changes from your SCM.                                                                       |
| changes                     | Generate a report from an issue tracker or a change document.                                                          |
| checkstyle                  | Generate a Checkstyle report.                                                                                          |
| doap                        | Generate a Description of a Project (DOAP) file from a POM.                                                            |
| docck                       | Documentation checker plugin.                                                                                          |
| javadoc                     | Generate Javadoc for the project.                                                                                      |
| jdeps                       | Run JDK's JDeps tool on the project.                                                                                   |
| jxr                         | Generate a source cross reference.                                                                                     |
| linkcheck                   | Generate a Linkcheck report of your project's documentation.                                                           |
| pmd                         | Generate a PMD report.                                                                                                 |
| project-info-reports        | Generate standard project reports.                                                                                     |
| surefire-report             | Generate a report based on the results of unit tests.                                                                  |
| ** Tools **                 | ** These are miscellaneous tools available through Maven by default. **                                                |
| antrun                      | Run a set of ant tasks from a phase of the build.                                                                      |
| archetype                   | Generate a skeleton project structure from an archetype.                                                               |
| assembly                    | Build an assembly (distribution) of sources and/or binaries.                                                           |
| dependency                  | Dependency manipulation (copy, unpack) and analysis.                                                                   |
| enforcer                    | Environmental constraint checking (Maven Version, JDK etc), User Custom Rule Execution.                                |
| gpg                         | Create signatures for the artifacts and poms.                                                                          |
| help                        | Get information about the working environment for the project.                                                         |
| invoker                     | Run a set of Maven projects and verify the output.                                                                     |
| jarsigner                   | Signs or verifies project artifacts.                                                                                   |
| jdeprscan                   | Run JDK's JDeprScan tool on the project.                                                                               |
| patch                       | Use the gnu patch tool to apply patch files to source code.                                                            |
| pdf                         | Generate a PDF version of your project's documentation.                                                                |
| plugin                      | Create a Maven plugin descriptor for any mojos found in the source tree, to include in the JAR.                        |
| release                     | Release the current project - updating the POM and tagging in the SCM.                                                 |
| remote-resources            | Copy remote resources to the output directory for inclusion in the artifact.                                           |
| scm                         | Execute SCM commands for the current project.                                                                          |
| scm-publish                 | Publish your Maven website to a scm location.                                                                          |
| stage                       | Assists with release staging and promotion.                                                                            |
| toolchains                  | Allows to share configuration across plugins.                                                                          |

# MojoHaus (or old-name:Mojo@Codehaus.org)
maven eklentileri geliştiren projedir. geliştirilen plugin'lerin listesi: (source-id: 437)

# Mojo (or Maven plain Old Java Object)
MojoHaus ismi buradan türemiştir. Each mojo is an executable goal in Maven, and a plugin is a distribution of one or more related mojos. maven plugin developer'larının bildiği bir terimdir. maven kullanan developer'ların bildiği bir terim diildir. kaynak: (source-id: 8)

# maven-deploy-plugin vs nexus-staging-maven-plugin
maven-deploy-plugin nexus sunucusuna deploy yapabiliyor. fakat nexus-staging-maven-plugin, sadece nexus sunucusuna özgü ek özellikler de barındırıyor (örnek: staging özelliği). opsiyonel olarak tercih edilebilir.

# findbugs vs checkstyle

  findbugs bytecode bazında projeyi inceleler ve hataları bulur. oysa checkstyle sadece source code'u check eder. ikisini de kullanmak gerekli. çünkü mimarileri gereği birbirlerinini yakalamadıkları sorunlar var.

# sık kullanılan bazı plugin'ler

- spring-boot-maven-plugin

  - Actuator tarafından kullanılmak üzere "build-info" generate edebiliyor.
  - maven komutları ile projeyi start edebilmemizi sağlıyor.
  - jar'ın içindeki manifest dosyasına Main classı tanımlayabilmemizi sağlıyor. böylece jar'ı run ederken, main class'ımızı parametre gerçek zorunda kalmıyoruz.

- maven-source-plugin

  source code'un özel (normal artifact'tan ayrı) bir jar oluşturup onun içine atıyor. genelde open source projeler veya şirket içinde internal geliştirmelerde buna ihtiyaç oluyor. bu şekilde uygulamamızı jar olarak dependency ekleyen projeler, projemizin kodlarını debug edebiliyor. fakat bu source jar'larında repository server'ına pushlanması gerekmektedir.

- build-helper-maven-plugin

  build aşaması için eksra özellikler içeriyor (bazıları maven-compiler-plugin ile de yapılabiliyor). örnek:

  - build aşamasında bazı directory'leri soruce kod olarak set edebilmemizi sağlıyor (örnek src/extra/java 'nında kod dizini olarak tanımlanmasını sağlıyor)

# pom'dan bilgi okuma

help plugini pom'dan bu şekilde bilgi okuyabilmemizi sağlıyor:

./mvnw help:evaluate -Dexpression=project.version -q -DforceStdout

# -DskipTests vs -Dmaven.test.skip=true
-DskipTests test kodlarını compile eder fakat testleri koşmaz.

-Dmaven.test.skip=true hem test kodlarını derlemiyor hemde testleri koşmuyor.

# paralel test
maven-surefire-plugin'in paralel test koşmak için seçenekleri vardır. bu seçeneklerin bazıları:

- forkCount

  - parametre olarak sayı alır.

  - default değeri 1'dir.
  
  - en fazla kaç adet jvm açılacağını belirtir.

- reuseFork

  - parametre olarak boolean alır.
  
  - true is by default.

  - forkCount'ta belirtilen sayıda jvm'in tekrar mı açılacağını yoksa, yeni bir test koşulduğunda aynı jvm'in mi tetikleneceği belirtilmektedir.

  - aynı jvm'in kullanılması @BeforeClass gibi kodların ortak çalışmasını sağlar. kaynak: (source-id: 9) "Parallel Test Execution" başlığı son paragraf.

- parallel

  - aynı jvm içerisinde hangi testlerin paralel koşulacağını belirlemek için kullanılır.

  - alacağı argüman test provider'ına göre değişir. örneğin junit 4.7'de şunları alabilir: methods, classes, both, suites, suitesAndClasses, suitesAndMethods, classesAndMethods, all.

# BOM
Bill Of Materials'in kısaltmasıdır. BOM'lar sadece dependency yönetimini sağlamak için oluşturulmuş projelerdir. 2 şekilde BOM'ları projemize import edebiliriz:
- dependency management'e import ederek:

```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>baeldung</groupId>
            <artifactId>Baeldung-BOM</artifactId>
            <version>0.0.1-SNAPSHOT</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

- parent vererek:

```xml
<parent>
    <groupId>baeldung</groupId>
    <artifactId>Baeldung-BOM</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</parent>
```
