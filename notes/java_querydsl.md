############################

############################
# JAVA QUERY DSL
############################

############################

# queryDSL
build sırasında code generation'ı yapararak, birçok java kütüphanesi için ek query sağlayan kütüphanedir. desteklediği kütüphaneler:

- jpa
- sql
- Mongodb
- Collections

jpa için örnek olarak kullanımına bakalım:

```xml
<dependencies>
    
    <dependency>
        <!-- this is for code generation on build time. so it is on provided scope which means this library exist only on build phase. -->
        <groupId>com.querydsl</groupId>
        <artifactId>querydsl-apt</artifactId>
        <version>${querydsl.version}</version>
        <scope>provided</scope>
    </dependency>
 
    <dependency>
        <!-- burada kullanmak istediğimiz java modülünü eklememiz şart -->
        <groupId>com.querydsl</groupId>
        <artifactId>querydsl-jpa</artifactId>
        <version>${querydsl.version}</version>
    </dependency>
 
</dependencies>

<plugin>
    <!-- this is for code generation on build time. -->
    <groupId>com.mysema.maven</groupId>
    <artifactId>apt-maven-plugin</artifactId>
    <version>1.1.3</version>
    <executions>
        <execution>
            <goals>
                <goal>process</goal>
            </goals>
            <configuration>
                <outputDirectory>target/generated-sources/java</outputDirectory>
                <processor>com.querydsl.apt.jpa.JPAAnnotationProcessor</processor>
            </configuration>
        </execution>
    </executions>
</plugin>
```

Java kodumuzda User isimli bir entity varsa; "mvn compile" komutunu çalıştırdığımızda QUser isimli bir sınıf generate edilecektir. QUser içerisinde birçok query yapabilmemizi sağlayan metod mevcuttur. örnek kullanım:

```java
EntityManagerFactory emf = Persistence.createEntityManagerFactory(); // default JPA class
EntityManager em = emf.createEntityManager(); // default JPA class

JPAQueryFactory queryFactory = new JPAQueryFactory(em); // com.querydsl.jpa.impl.JPAQueryFactory

QUser user = QUser.user; // QUser is auto-generated by querydls library. QUser includes a default instance of QUser as static.

// simple get example
User c = queryFactory.selectFrom(user)
                              .where(user.login.eq("David"))
                              .fetchOne();

// order example
List<User> c = queryFactory.selectFrom(user)
                                  .orderBy(user.login.asc())
                                  .fetch();

// update example
queryFactory.update(user)
  .where(user.login.eq("Ash"))
  .set(user.login, "Ash2")
  .set(user.disabled, true)
  .execute();

// delete example
queryFactory.delete(user)
  .where(user.login.eq("David"))
  .execute();
```

# Predicate
Predicate kelime anlamı: yüklem, doğrulamak, belirtmek

örnek:

```java
import org.springframework.data.querydsl.binding.QuerydslPredicate;
import com.querydsl.core.types.Predicate;

@GetMapping(value = "/users")
public Page<UserDto> fetchUsers(
                               @QuerydslPredicate(root = UserDBEntity.class) Predicate predicate,

                               // "pageable" başka başlıkta anlatılıyor. bu konudan bağımsız. burada sadece birlikte kullanılabileceğini göstermeye çalıştım. pageable'ın konulması zorunlu diil.
                               Pageable pageable
                               ) {
    
    // repository should extends org.springframework.data.querydsl.QuerydslPredicateExecutor<UserDBEntity>
    Page<User> userListPageable = userRepository.findAll(predicate, pageable);

    // mpToDto queryDsl'den bağımsız bir konu. db entity'sini dönmemek için burada basit bir mapping yapıldı.
    return userListPageable.map(UserDBEntity -> mapperUtil.mapToDto(UserDBEntity));
}
```

@QuerydslPredicate direk query'nin parametre olarak inject edilmesini sağlıyor. Aynı Pageable 'in yaptığı gibi.

```java
// com.querydsl.core.types.dsl.BooleanExpression
BooleanExpression b = QUser.user.email.eq("ahmet@gmail.com");
```

BooleanExpression implements com.querydsl.core.types.Predicate interface.

# Criteria and Predicate classes of JPA

"Spring data" da bu import'ları kullanır. Çünkü spring-data JPA'yı wrap ediyor.

```java
import javax.persistence.EntityManager;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Root;

class BookDao {

    EntityManager em;

    List<Book> findBooksByAuthorNameAndTitle(String authorName, String title) {
        CriteriaBuilder cb = em.getCriteriaBuilder();
        CriteriaQuery<Book> cq = cb.createQuery(Book.class);

        Root<Book> book = cq.from(Book.class);
        Predicate authorNamePredicate = cb.equal(book.get("author"), authorName);
        Predicate titlePredicate = cb.like(book.get("title"), "%" + title + "%");
        cq.where(authorNamePredicate, titlePredicate);

        TypedQuery<Book> query = em.createQuery(cq);
        return query.getResultList();
    }
}
```
